# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _libmapper
else:
    import _libmapper

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


INT32 = _libmapper.INT32
INT64 = _libmapper.INT64
FLT = _libmapper.FLT
DBL = _libmapper.DBL
STR = _libmapper.STR
BOOL = _libmapper.BOOL
TIME = _libmapper.TIME
TYPE = _libmapper.TYPE
PTR = _libmapper.PTR
DEV = _libmapper.DEV
SIG = _libmapper.SIG
SIG_IN = _libmapper.SIG_IN
SIG_OUT = _libmapper.SIG_OUT
MAP = _libmapper.MAP
MAP_IN = _libmapper.MAP_IN
MAP_OUT = _libmapper.MAP_OUT
OBJ = _libmapper.OBJ
LIST = _libmapper.LIST
NULL = _libmapper.NULL
PROP_UNKNOWN = _libmapper.PROP_UNKNOWN
PROP_BUNDLE = _libmapper.PROP_BUNDLE
PROP_DEV = _libmapper.PROP_DEV
PROP_DIR = _libmapper.PROP_DIR
PROP_EPHEM = _libmapper.PROP_EPHEM
PROP_EXPR = _libmapper.PROP_EXPR
PROP_HOST = _libmapper.PROP_HOST
PROP_ID = _libmapper.PROP_ID
PROP_INST = _libmapper.PROP_INST
PROP_IS_LOCAL = _libmapper.PROP_IS_LOCAL
PROP_JITTER = _libmapper.PROP_JITTER
PROP_LEN = _libmapper.PROP_LEN
PROP_LIBVER = _libmapper.PROP_LIBVER
PROP_LINKED = _libmapper.PROP_LINKED
PROP_MAX = _libmapper.PROP_MAX
PROP_MIN = _libmapper.PROP_MIN
PROP_MUTED = _libmapper.PROP_MUTED
PROP_NAME = _libmapper.PROP_NAME
PROP_NUM_INST = _libmapper.PROP_NUM_INST
PROP_NUM_MAPS = _libmapper.PROP_NUM_MAPS
PROP_NUM_MAPS_IN = _libmapper.PROP_NUM_MAPS_IN
PROP_NUM_MAPS_OUT = _libmapper.PROP_NUM_MAPS_OUT
PROP_NUM_SIGS_IN = _libmapper.PROP_NUM_SIGS_IN
PROP_NUM_SIGS_OUT = _libmapper.PROP_NUM_SIGS_OUT
PROP_ORDINAL = _libmapper.PROP_ORDINAL
PROP_PERIOD = _libmapper.PROP_PERIOD
PROP_PORT = _libmapper.PROP_PORT
PROP_PROCESS_LOC = _libmapper.PROP_PROCESS_LOC
PROP_PROTOCOL = _libmapper.PROP_PROTOCOL
PROP_RATE = _libmapper.PROP_RATE
PROP_SCOPE = _libmapper.PROP_SCOPE
PROP_SIG = _libmapper.PROP_SIG
PROP_STATUS = _libmapper.PROP_STATUS
PROP_STEAL_MODE = _libmapper.PROP_STEAL_MODE
PROP_SYNCED = _libmapper.PROP_SYNCED
PROP_TYPE = _libmapper.PROP_TYPE
PROP_UNIT = _libmapper.PROP_UNIT
PROP_USE_INST = _libmapper.PROP_USE_INST
PROP_DATA = _libmapper.PROP_DATA
PROP_VERSION = _libmapper.PROP_VERSION
OP_NEX = _libmapper.OP_NEX
OP_EQ = _libmapper.OP_EQ
OP_EX = _libmapper.OP_EX
OP_GT = _libmapper.OP_GT
OP_GTE = _libmapper.OP_GTE
OP_LT = _libmapper.OP_LT
OP_LTE = _libmapper.OP_LTE
OP_NEQ = _libmapper.OP_NEQ
LOC_UNDEFINED = _libmapper.LOC_UNDEFINED
LOC_SRC = _libmapper.LOC_SRC
LOC_DST = _libmapper.LOC_DST
LOC_ANY = _libmapper.LOC_ANY
PROTO_UNDEFINED = _libmapper.PROTO_UNDEFINED
PROTO_UDP = _libmapper.PROTO_UDP
PROTO_TCP = _libmapper.PROTO_TCP
DIR_UNDEFINED = _libmapper.DIR_UNDEFINED
DIR_IN = _libmapper.DIR_IN
DIR_OUT = _libmapper.DIR_OUT
DIR_ANY = _libmapper.DIR_ANY
SIG_INST_NEW = _libmapper.SIG_INST_NEW
SIG_REL_UPSTRM = _libmapper.SIG_REL_UPSTRM
SIG_REL_DNSTRM = _libmapper.SIG_REL_DNSTRM
SIG_INST_OFLW = _libmapper.SIG_INST_OFLW
SIG_UPDATE = _libmapper.SIG_UPDATE
SIG_ALL = _libmapper.SIG_ALL
STEAL_NONE = _libmapper.STEAL_NONE
STEAL_OLDEST = _libmapper.STEAL_OLDEST
STEAL_NEWEST = _libmapper.STEAL_NEWEST
OBJ_NEW = _libmapper.OBJ_NEW
OBJ_MOD = _libmapper.OBJ_MOD
OBJ_REM = _libmapper.OBJ_REM
OBJ_EXP = _libmapper.OBJ_EXP
STATUS_RESERVED = _libmapper.STATUS_RESERVED
STATUS_STAGED = _libmapper.STATUS_STAGED
STATUS_READY = _libmapper.STATUS_READY
STATUS_ACTIVE = _libmapper.STATUS_ACTIVE
version = _libmapper.version
class device(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, name: "char const *", DISOWN: "graph"=None):
        _libmapper.device_swiginit(self, _libmapper.new_device(name, DISOWN))
    __swig_destroy__ = _libmapper.delete_device

    def graph(self) -> "graph *":
        return _libmapper.device_graph(self)

    def add_signal(self, *args) -> "signal *":
        return _libmapper.device_add_signal(self, *args)

    def remove_signal(self, sig: "signal") -> "device *":
        return _libmapper.device_remove_signal(self, sig)

    def update_maps(self) -> "device *":
        return _libmapper.device_update_maps(self)

    def poll(self, timeout: "int"=0) -> "int":
        return _libmapper.device_poll(self, timeout)

    def get_time(self) -> "time *":
        return _libmapper.device_get_time(self)

    def set_time(self, py_tt: "time") -> "device *":
        return _libmapper.device_set_time(self, py_tt)

    def generate_unique_id(self) -> "mpr_id":
        return _libmapper.device_generate_unique_id(self)

    def get_num_properties(self) -> "int":
        return _libmapper.device_get_num_properties(self)

    def get_is_ready(self) -> "booltype":
        return _libmapper.device_get_is_ready(self)

    def get_property(self, *args) -> "named_prop":
        return _libmapper.device_get_property(self, *args)

    def set_property(self, *args) -> "device *":
        return _libmapper.device_set_property(self, *args)

    def remove_property(self, *args) -> "device *":
        return _libmapper.device_remove_property(self, *args)

    def push(self) -> "device *":
        return _libmapper.device_push(self)

    def signals(self, *args) -> "signal_list *":
        return _libmapper.device_signals(self, *args)

    def maps(self, *args) -> "map_list *":
        return _libmapper.device_maps(self, *args)

    num_properties = property(get_num_properties)
    ready = property(get_is_ready)
    def get_properties(self):
        props = {}
        for i in range(self.num_properties):
            prop = self.get_property(i)
            if prop:
                props[prop[0]] = prop[1];
        return props
    def __propgetter(self):
        device = self
        props = self.get_properties()
        class propsetter(dict):
            __getitem__ = props.__getitem__
            def __setitem__(self, key, val):
                props[key] = val
                device.set_property(key, val)
        return propsetter(self.get_properties())
    properties = property(__propgetter)
    def set_properties(self, props):
        [self.set_property(k, props[k]) for k in props]
    def __getitem__(self, key):
        return self.get_property(key)
    def __setitem__(self, key, val):
        self.set_property(key, val)
        return self;
    def __nonzero__(self):
        return False if self.this is None else True
    def __eq__(self, rhs):
        return rhs != None and self['id'] == rhs['id']


# Register device in _libmapper:
_libmapper.device_swigregister(device)

class signal(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def device(self) -> "device *":
        return _libmapper.signal_device(self)

    def instance_id(self, *args) -> "int":
        return _libmapper.signal_instance_id(self, *args)

    def release_instance(self, id: "int") -> "signal *":
        return _libmapper.signal_release_instance(self, id)

    def remove_instance(self, id: "int") -> "signal *":
        return _libmapper.signal_remove_instance(self, id)

    def reserve_instances(self, *args) -> "signal *":
        return _libmapper.signal_reserve_instances(self, *args)

    def set_callback(self, *args) -> "signal *":
        return _libmapper.signal_set_callback(self, *args)

    def set_value(self, *args) -> "signal *":
        return _libmapper.signal_set_value(self, *args)

    def get_num_properties(self) -> "int":
        return _libmapper.signal_get_num_properties(self)

    def num_instances(self, *args) -> "int":
        return _libmapper.signal_num_instances(self, *args)

    def get_property(self, *args) -> "named_prop":
        return _libmapper.signal_get_property(self, *args)

    def value(self, *args) -> "propval":
        return _libmapper.signal_value(self, *args)

    def set_property(self, *args) -> "signal *":
        return _libmapper.signal_set_property(self, *args)

    def remove_property(self, *args) -> "signal *":
        return _libmapper.signal_remove_property(self, *args)

    def push(self) -> "signal *":
        return _libmapper.signal_push(self)

    def maps(self, *args) -> "map_list *":
        return _libmapper.signal_maps(self, *args)

    num_properties = property(get_num_properties)
    def get_properties(self):
        props = {}
        for i in range(self.num_properties):
            prop = self.get_property(i)
            if prop:
                props[prop[0]] = prop[1];
        return props
    def __propgetter(self):
        signal = self
        props = self.get_properties()
        class propsetter(dict):
            __getitem__ = props.__getitem__
            def __setitem__(self, key, val):
                props[key] = val
                signal.set_property(key, val)
        return propsetter(self.get_properties())
    properties = property(__propgetter)
    def set_properties(self, props):
        [self.set_property(k, props[k]) for k in props]
    def __getitem__(self, key):
        return self.get_property(key)
    def __setitem__(self, key, val):
        self.set_property(key, val)
        return self;
    def __nonzero__(self):
        return False if self.this is None else True
    def __eq__(self, rhs):
        return rhs != None and self['id'] == rhs['id']


    def __init__(self):
        _libmapper.signal_swiginit(self, _libmapper.new_signal())
    __swig_destroy__ = _libmapper.delete_signal

# Register signal in _libmapper:
_libmapper.signal_swigregister(signal)

class map(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _libmapper.map_swiginit(self, _libmapper.new_map(*args))
    __swig_destroy__ = _libmapper.delete_map

    def refresh(self) -> "map *":
        return _libmapper.map_refresh(self)

    def release(self) -> "void":
        return _libmapper.map_release(self)

    def signals(self, *args) -> "signal_list *":
        return _libmapper.map_signals(self, *args)

    def signal(self, *args) -> "signal *":
        return _libmapper.map_signal(self, *args)

    def index(self, sig: "signal") -> "int":
        return _libmapper.map_index(self, sig)

    def add_scope(self, dev: "device") -> "map *":
        return _libmapper.map_add_scope(self, dev)

    def remove_scope(self, dev: "device") -> "map *":
        return _libmapper.map_remove_scope(self, dev)

    def get_num_properties(self) -> "int":
        return _libmapper.map_get_num_properties(self)

    def get_ready(self) -> "booltype":
        return _libmapper.map_get_ready(self)

    def get_property(self, *args) -> "named_prop":
        return _libmapper.map_get_property(self, *args)

    def set_property(self, *args) -> "map *":
        return _libmapper.map_set_property(self, *args)

    def remove_property(self, *args) -> "map *":
        return _libmapper.map_remove_property(self, *args)

    def push(self) -> "map *":
        return _libmapper.map_push(self)

    num_properties = property(get_num_properties)
    ready = property(get_ready)
    def get_properties(self):
        props = {}
        for i in range(self.num_properties):
            prop = self.get_property(i)
            if prop:
                props[prop[0]] = prop[1];
        return props
    def __propgetter(self):
        map = self
        props = self.get_properties()
        class propsetter(dict):
            __getitem__ = props.__getitem__
            def __setitem__(self, key, val):
                props[key] = val
                map.set_property(key, val, true)
        return propsetter(self.get_properties())
    properties = property(__propgetter)
    def set_properties(self, props):
        [self.set_property(k, props[k]) for k in props]
    def __getitem__(self, key):
        return self.get_property(key)
    def __setitem__(self, key, val):
        self.set_property(key, val)
        return self;
    def __nonzero__(self):
        return False if self.this is None else True
    def __eq__(self, rhs):
        return rhs != None and self['id'] == rhs['id']


# Register map in _libmapper:
_libmapper.map_swigregister(map)

class graph(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, flags: "int"=0):
        _libmapper.graph_swiginit(self, _libmapper.new_graph(flags))
    __swig_destroy__ = _libmapper.delete_graph

    def get_interface(self) -> "char const *":
        return _libmapper.graph_get_interface(self)

    def set_interface(self, iface: "char const *") -> "graph *":
        return _libmapper.graph_set_interface(self, iface)

    def get_address(self) -> "char const *":
        return _libmapper.graph_get_address(self)

    def set_address(self, group: "char const *", port: "int") -> "graph *":
        return _libmapper.graph_set_address(self, group, port)

    def poll(self, timeout: "int"=0) -> "int":
        return _libmapper.graph_poll(self, timeout)

    def subscribe(self, *args) -> "graph *":
        return _libmapper.graph_subscribe(self, *args)

    def unsubscribe(self, dev: "device"=None) -> "graph *":
        return _libmapper.graph_unsubscribe(self, dev)

    def add_callback(self, *args) -> "graph *":
        return _libmapper.graph_add_callback(self, *args)

    def remove_callback(self, PyFunc: "PyObject *") -> "graph *":
        return _libmapper.graph_remove_callback(self, PyFunc)

    def devices(self) -> "device_list *":
        return _libmapper.graph_devices(self)

    def signals(self) -> "signal_list *":
        return _libmapper.graph_signals(self)

    def maps(self) -> "map_list *":
        return _libmapper.graph_maps(self)

    interface = property(get_interface, set_interface)
    address = property(get_address, set_address)
    def __nonzero__(self):
        return False if self.this is None else True


# Register graph in _libmapper:
_libmapper.graph_swigregister(graph)

class time(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _libmapper.time_swiginit(self, _libmapper.new_time(*args))
    __swig_destroy__ = _libmapper.delete_time

    def now(self) -> "time *":
        return _libmapper.time_now(self)

    def get_double(self) -> "double":
        return _libmapper.time_get_double(self)

    def __add__(self, *args) -> "time *":
        return _libmapper.time___add__(self, *args)

    def __iadd__(self, *args) -> "time *":
        return _libmapper.time___iadd__(self, *args)

    def __radd__(self, val: "double") -> "double":
        return _libmapper.time___radd__(self, val)

    def __sub__(self, *args) -> "time *":
        return _libmapper.time___sub__(self, *args)

    def __isub__(self, *args) -> "time *":
        return _libmapper.time___isub__(self, *args)

    def __rsub__(self, val: "double") -> "double":
        return _libmapper.time___rsub__(self, val)

    def __mul__(self, multiplicand: "double") -> "time *":
        return _libmapper.time___mul__(self, multiplicand)

    def __imul__(self, multiplicand: "double") -> "time *":
        return _libmapper.time___imul__(self, multiplicand)

    def __rmul__(self, val: "double") -> "double":
        return _libmapper.time___rmul__(self, val)

    def __div__(self, divisor: "double") -> "time *":
        return _libmapper.time___div__(self, divisor)

    def __idiv__(self, divisor: "double") -> "time *":
        return _libmapper.time___idiv__(self, divisor)

    def __rdiv__(self, val: "double") -> "double":
        return _libmapper.time___rdiv__(self, val)

    def __lt__(self, *args) -> "booltype":
        return _libmapper.time___lt__(self, *args)

    def __le__(self, *args) -> "booltype":
        return _libmapper.time___le__(self, *args)

    def __eq__(self, *args) -> "booltype":
        return _libmapper.time___eq__(self, *args)

    def __ge__(self, *args) -> "booltype":
        return _libmapper.time___ge__(self, *args)

    def __gt__(self, *args) -> "booltype":
        return _libmapper.time___gt__(self, *args)

# Register time in _libmapper:
_libmapper.time_swigregister(time)

class device_list(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    list = property(_libmapper.device_list_list_get, _libmapper.device_list_list_set)

    def __init__(self, orig: "device_list"):
        _libmapper.device_list_swiginit(self, _libmapper.new_device_list(orig))
    __swig_destroy__ = _libmapper.delete_device_list

    def __iter__(self) -> "struct _device_list *":
        return _libmapper.device_list___iter__(self)

    def next(self) -> "device *":
        return _libmapper.device_list_next(self)

    def join(self, d: "device_list") -> "device_list *":
        return _libmapper.device_list_join(self, d)

    def intersect(self, d: "device_list") -> "device_list *":
        return _libmapper.device_list_intersect(self, d)

    def subtract(self, d: "device_list") -> "device_list *":
        return _libmapper.device_list_subtract(self, d)

    def filter(self, *args) -> "device_list *":
        return _libmapper.device_list_filter(self, *args)

    def length(self) -> "int":
        return _libmapper.device_list_length(self)

    def __getitem__(self, index: "int") -> "device *":
        return _libmapper.device_list___getitem__(self, index)

    def __next__(self):
        return self.next()
    def __len__(self):
        return self.length()


# Register device_list in _libmapper:
_libmapper.device_list_swigregister(device_list)

class signal_list(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    list = property(_libmapper.signal_list_list_get, _libmapper.signal_list_list_set)

    def __init__(self, orig: "signal_list"):
        _libmapper.signal_list_swiginit(self, _libmapper.new_signal_list(orig))
    __swig_destroy__ = _libmapper.delete_signal_list

    def __iter__(self) -> "struct _signal_list *":
        return _libmapper.signal_list___iter__(self)

    def next(self) -> "signal *":
        return _libmapper.signal_list_next(self)

    def join(self, s: "signal_list") -> "signal_list *":
        return _libmapper.signal_list_join(self, s)

    def intersect(self, s: "signal_list") -> "signal_list *":
        return _libmapper.signal_list_intersect(self, s)

    def subtract(self, s: "signal_list") -> "signal_list *":
        return _libmapper.signal_list_subtract(self, s)

    def filter(self, *args) -> "signal_list *":
        return _libmapper.signal_list_filter(self, *args)

    def length(self) -> "int":
        return _libmapper.signal_list_length(self)

    def __getitem__(self, index: "int") -> "signal *":
        return _libmapper.signal_list___getitem__(self, index)

    def __next__(self):
        return self.next()
    def __len__(self):
        return self.length()


# Register signal_list in _libmapper:
_libmapper.signal_list_swigregister(signal_list)

class map_list(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    list = property(_libmapper.map_list_list_get, _libmapper.map_list_list_set)

    def __init__(self, orig: "map_list"):
        _libmapper.map_list_swiginit(self, _libmapper.new_map_list(orig))
    __swig_destroy__ = _libmapper.delete_map_list

    def __iter__(self) -> "struct _map_list *":
        return _libmapper.map_list___iter__(self)

    def next(self) -> "map *":
        return _libmapper.map_list_next(self)

    def join(self, m: "map_list") -> "map_list *":
        return _libmapper.map_list_join(self, m)

    def intersect(self, m: "map_list") -> "map_list *":
        return _libmapper.map_list_intersect(self, m)

    def subtract(self, m: "map_list") -> "map_list *":
        return _libmapper.map_list_subtract(self, m)

    def filter(self, *args) -> "map_list *":
        return _libmapper.map_list_filter(self, *args)

    def length(self) -> "int":
        return _libmapper.map_list_length(self)

    def __getitem__(self, index: "int") -> "map *":
        return _libmapper.map_list___getitem__(self, index)

    def release(self) -> "map_list *":
        return _libmapper.map_list_release(self)

    def __next__(self):
        return self.next()
    def __len__(self):
        return self.length()


# Register map_list in _libmapper:
_libmapper.map_list_swigregister(map_list)



